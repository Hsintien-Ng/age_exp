import os
import csv
from PIL import Image
import numpy as np
import matplotlib.pyplot as plt

EXP_NAME = {0: 'neutral', 1: 'happy', 2: 'sad', 3: 'surprise',
            4: 'fear', 5: 'disgust', 6: 'anger', 7: 'contempt',
            8: 'None', 9: 'uncertain', 10: 'Non-Face',
            -1: 'Error'}

class AFItem:

    def __init__(self):
        self.path = ''
        self.face_x = 0
        self.face_y = 0
        self.width = 0
        self.height = 0
        self.landmark = []
        self.expression = -1

    def from_exp_wise_index(self, path, face_box, landmark, expression):
        self.path = path
        box = [int(p) for p in face_box.split()]
        self.face_x = box[0]
        self.face_y = box[1]
        self.width = box[2]
        self.height = box[3]
        self.landmark = [float(p) for p in landmark.split()]
        self.expression = expression

    def from_original_index(self, attributes):
        self.path = attributes[0]
        if attributes[1] != 'NULL':
            self.face_x = int(attributes[1])
            self.face_y = int(attributes[2])
            self.width = int(attributes[3])
            self.height = int(attributes[4])
            self.landmark = [float(p) for p in attributes[5].split(';')]
            self.expression = int(attributes[6])
        else:
            self.expression = -1

    def face_ratio(self, work_dir):
        """
        Calculate the ratio of face's area over img's
        :param work_dir:
        :return:
        """
        if self.expression == -1:
            return -1, -1
        else:
            path = os.path.join(work_dir, self.path)
            try:
                img_size = Image.open(path).size
                img_area = img_size[0]*img_size[1]
                face_area = self.height*self.width
            except:
                img_size = (0, 0)
                img_area = 1
                face_area = 0
            return face_area*1.0/img_area, img_size

    def get_image(self, work_dir):
        path = os.path.join(work_dir, self.path)
        img = Image.open(path)
        return img

    def self_crop(self, work_dir):
        """
        Crop face respected to bounding box given by index file
        :param work_dir:
        :return:
        """
        path = os.path.join(work_dir, self.path)
        img = Image.open(path)
        ROI = (self.face_x, self.face_y,
               self.face_x+self.width,
               self.face_y+self.height)
        print(ROI)
        cropped = img.crop(ROI)
        return cropped

    def self_print(self):
        all_vars = vars(self)
        for var in all_vars:
            print('{}: {}'.format(var, all_vars[var]))

class AFDataset:

    def __init__(self):
        self.exps = {}

    def from_exp_wise_index(self, index_dir):
        """
        Init by reading expression wise index files generated by function
        generate_exp_wise_index
        :param index_dir:
        :return:
        """
        # for first 8 expression only
        for exp in range(0, 8):
            self.exps[exp] = []
            index_file_path = os.path.join(index_dir, '%s_index.txt' % EXP_NAME[exp])
            landmark_file_path = os.path.join(index_dir, '%s_landmark.txt' % EXP_NAME[exp])
            face_box_file_path = os.path.join(index_dir, '%s_box.txt' % EXP_NAME[exp])
            index_file = open(index_file_path, 'r')
            landmark_file = open(landmark_file_path, 'r')
            face_box_file = open(face_box_file_path, 'r')
            print(exp)

            try:
                while True:
                    path = index_file.readline().strip()
                    landmark_file.readline()
                    landmark = landmark_file.readline()
                    face_box_file.readline()
                    box = face_box_file.readline()
                    item = AFItem()
                    item.from_exp_wise_index(path, box, landmark, exp)
                    self.exps[exp].append(item)
            except:
                pass

            index_file.close()
            landmark_file.close()
            face_box_file.close()

    def from_original_index(self, index_path):
        """
        Read index file and save items by their expression, from the original
        index file.
        :param index_path:
        """
        reader = csv.reader(open(index_path))
        header = next(reader)
        count = 0
        for line in reader:
            if count % 100000 == 0:
                print(count)
            af_item = AFItem()
            af_item.from_original_index(line)
            if af_item.expression in self.exps:
                self.exps[af_item.expression].append(af_item)
            else:
                self.exps[af_item.expression] = [af_item]
            count += 1
        print('completed')

    def generate_exp_wise_index(self, output_path):
        """
        Generate index file, landmark file, bounding box file for each expression
        :param output_path:
        :return:
        """
        for exp in self.exps:
            items = self.exps[exp]
            index_file_path = os.path.join(output_path, '%s_index.txt' % EXP_NAME[exp])
            landmark_file_path = os.path.join(output_path, '%s_landmark.txt' % EXP_NAME[exp])
            face_box_file_path = os.path.join(output_path, '%s_box.txt' % EXP_NAME[exp])
            index_file = open(index_file_path, 'w+')
            landmark_file = open(landmark_file_path, 'w+')
            face_box_file = open(face_box_file_path, 'w+')
            print(exp)
            for item in items:
                index_file.write('%s\n' % item.path)
                if exp == -1:
                    continue
                landmark_file.write('%s\n' % item.path)
                for p in item.landmark:
                    landmark_file.write('%f ' % p)
                landmark_file.write('\n')
                face_box_file.write('%s\n%i %i %i %i\n' % (item.path,
                                    item.face_x, item.face_y,
                                    item.width, item.height))

            index_file.close()
            landmark_file.close()
            face_box_file.close()

    def exp_wise_statistics(self, work_dir, output_path):
        """
        Generate statistics file, which contains information of face ratio and
        image size, for each expression
        :param work_dir:
        :param output_path:
        :return:
        """
        for exp in self.exps:
            items = self.exps[exp]
            size_file_path = os.path.join(output_path, '%s_size.txt' % EXP_NAME[exp])
            size_file = open(size_file_path, 'w+')
            print(exp)
            for item in items:
                ratio, size = item.face_ratio(work_dir)
                size_file.write('{}\n{} {} {}\n'.format(item.path.strip(), ratio, size[0], size[1]))

            size_file.close()

    def read_size_file(self, exp_id, file_dir):
        """
        read file generated by function exp_wise_statistics, which contains
        statistics information of a single expression.
        :param exp_id:
        :param file_dir:
        :return: a list of dictionary.
        """
        size_file_path = os.path.join(file_dir, '%s_size.txt' % EXP_NAME[exp_id])
        size_file = open(size_file_path, 'r')
        stats = []
        try:
            while(True):
                path = size_file.readline()
                data = size_file.readline()
                ratio, width, height = data.split(' ')
                stats.append({'ratio': float(ratio), "size": (int(width), int(height))})
        except:
            pass
        return stats

    def statistics_face_ratio_and_size(self, statistics_file_dir):
        """
        Calculate face ratio over the whole img, and max/min/average
        size for each expression.
        We count the number of img whose face ratio over the whole img
        at each percentage.
        :param statistics_file_dir: directory of statistics file, generated
                by function exp_wise_size
        :return:
        """
        self.face_ratios = {}
        self.size_statistics = {}
        # for expression 0~7 only
        for i in range(0, 8):
            print('%s start' % EXP_NAME[i])
            max_height = 0
            min_height = 10000
            max_width = 0
            min_width = 10000
            width_count = 0
            height_count = 0

            self.face_ratios[EXP_NAME[i]] = []
            exp_ratios = self.face_ratios[EXP_NAME[i]]
            self.size_statistics[EXP_NAME[i]] = {}
            size_stat = self.size_statistics[EXP_NAME[i]]
            # record number of img at 0~100 percentage
            for j in range(0, 101):
                exp_ratios.append(0)

            # for each expression:
            count = 0
            stats = self.read_size_file(i, statistics_file_dir)
            for stat in stats:
                ratio = stat['ratio']
                size = stat['size']
                if size[0] == 0:
                    print('no pic')
                    continue
                # here bounding box is a square, and may bigger than
                # img if img is not
                ratio = min(1, ratio)
                exp_ratios[int(ratio*100)] += 1

                max_width = max(max_width, size[0])
                max_height = max(max_height, size[1])
                min_width = min(min_width, size[0])
                min_height = min(min_height, size[1])
                width_count += size[0]
                height_count += size[1]

                count += 1

            size_stat['max_width'] = max_width
            size_stat['max_height'] = max_height
            size_stat['min_width'] = min_width
            size_stat['min_height'] = min_height
            size_stat['ave_width'] = width_count*1.0/count
            size_stat['ave_height'] = height_count*1.0/count
            print('%s end' % EXP_NAME[i])
        print('done')

    def plot_statistics_result(self, exp_id):
        exp_name = EXP_NAME[exp_id]
        x = np.arange(0, 101)
        y = np.array(self.face_ratios[exp_name])*1.0
        sum_y = y.sum()
        y = y/sum_y
        plt.bar(x, y)
        for x, y in zip(x, y):
            #plt.text(x, y + 0.2, '%.1f' % y, ha='center', va='bottom')
            print('{}: {}'.format(x, y))

        size_stat = self.size_statistics[exp_name]
        for stat in size_stat:
            print('{}: {}'.format(stat, size_stat[stat]))

    def distill(self, exp_wise_index_dir, output_dir):
        """
        I found some img missed when doing statistics, so this function
        will distill all missing record according to the statistics file.
        :param exp_wise_index_dir:
        :param output_dir:
        :return:
        """
        def read_write(read_file, write_file, line_num):
            for i in range(line_num):
                line = read_file.readline()
                write_file.write('%s' % line)

        def read_only(read_file, line_num):
            for i in range(line_num):
                read_file.readline()

        # for first 8 expression only
        for exp in range(0, 8):

            titles = ['{}_index.txt', '{}_landmark.txt', '{}_box.txt']
            # number of lines that one record may takes
            line_num = [1, 2, 2]
            old_files = []
            new_files = []
            for title in titles:
                old_path = os.path.join(exp_wise_index_dir, title.format(EXP_NAME[exp]))
                new_path = os.path.join(output_dir, title.format(EXP_NAME[exp]))
                old_files.append(open(old_path, 'r'))
                new_files.append(open(new_path, 'w+'))
            stats = self.read_size_file(exp, exp_wise_index_dir)
            count = 0
            for i in range(titles.__len__()):
                for stat in stats:
                    if stat['size'][0] == 0:
                        count += 1
                        read_only(read_file=old_files[i], line_num=line_num[i])
                    else:
                        read_write(old_files[i], new_files[i], line_num[i])
                old_files[i].close()
                new_files[i].close()
            print("expression %i has %i missing img" % (exp, count/3))



if __name__ == '__main__':
    AF_dir = os.path.join('/', 'mnt', 'disk50', 'datasets', 'AffectNet')
    exp_wise_index_dir = os.path.join('/', 'home', 'yjfu', 'age_exp', 'AffectNet_index_val')
    #index_path = os.path.join(AF_dir, 'training.csv')
    index_path = os.path.join(AF_dir, 'validation.csv')
    af_data_path = os.path.join('/', 'mnt', 'disk50', 'datasets', 'AffectNet', 'Manually_Annotated_Images')
    distilled_index_dir = os.path.join('/', 'home', 'yjfu', 'age_exp', 'AffectNet_index_distill_val')

    af = AFDataset()
    #af.from_original_index(index_path)
    #af.generate_exp_wise_index(exp_wise_index_dir)
    af.from_exp_wise_index(exp_wise_index_dir)
    af.exp_wise_statistics(af_data_path, exp_wise_index_dir)
    af.distill(exp_wise_index_dir, distilled_index_dir)

